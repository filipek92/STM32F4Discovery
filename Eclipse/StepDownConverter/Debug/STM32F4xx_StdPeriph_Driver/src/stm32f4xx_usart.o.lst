   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"stm32f4xx_usart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.align	2
  19              		.global	USART_DeInit
  20              		.thumb
  21              		.thumb_func
  23              	USART_DeInit:
  24              	.LFB110:
  25              		.file 1 "../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c"
   1:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
   2:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ******************************************************************************
   3:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @file    stm32f4xx_usart.c
   4:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @author  MCD Application Team
   5:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @version V1.0.0
   6:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @date    30-September-2011
   7:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          transmitter (USART):           
  10:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Initialization and Configuration
  11:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Data transfers
  12:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Multi-Processor Communication
  13:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - LIN mode
  14:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Half-duplex mode
  15:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Smartcard mode
  16:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - IrDA mode
  17:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - DMA transfers management
  18:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Interrupts and flags management 
  19:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           
  20:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *  @verbatim
  21:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *      
  22:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          ===================================================================
  23:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                                 How to use this driver
  24:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          ===================================================================
  25:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          1. Enable peripheral clock using the follwoing functions
  26:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
  27:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or 
  28:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  29:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          2.  According to the USART mode, enable the GPIO clocks using 
  30:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
  31:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *              or/and SCLK). 
  32:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  33:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          3. Peripheral's alternate function: 
  34:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Connect the pin to the desired peripherals' Alternate 
  35:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   Function (AF) using GPIO_PinAFConfig() function
  36:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Configure the desired pin in alternate function by:
  37:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
  38:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Select the type, pull-up/pull-down and output speed via 
  39:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
  40:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Call GPIO_Init() function
  41:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *        
  42:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
  43:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
  44:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             function.
  45:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  46:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          5. For synchronous mode, enable the clock and program the polarity,
  47:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             phase and last bit using the USART_ClockInit() function.
  48:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  49:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          5. Enable the NVIC and the corresponding interrupt using the function 
  50:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             USART_ITConfig() if you need to use interrupt mode. 
  51:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  52:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          6. When using the DMA mode 
  53:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   - Configure the DMA using DMA_Init() function
  54:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   - Active the needed channel Request using USART_DMACmd() function
  55:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * 
  56:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          7. Enable the USART using the USART_Cmd() function.
  57:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * 
  58:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
  59:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  60:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  61:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          for more details
  62:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          
  63:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          In order to reach higher communication baudrates, it is possible to
  64:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
  65:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd(
  66:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          and before calling the function USART_Init().
  67:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          
  68:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *  @endverbatim
  69:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *        
  70:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ******************************************************************************
  71:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @attention
  72:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  73:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  74:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  75:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  76:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  77:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  78:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  79:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  80:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  81:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ******************************************************************************  
  82:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */ 
  83:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  84:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Includes ------------------------------------------------------------------*/
  85:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #include "stm32f4xx_usart.h"
  86:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #include "stm32f4xx_rcc.h"
  87:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  88:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  89:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
  90:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
  91:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  92:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART 
  93:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief USART driver modules
  94:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
  95:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
  96:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  97:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private typedef -----------------------------------------------------------*/
  98:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private define ------------------------------------------------------------*/
  99:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 100:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
 101:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
 102:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
 103:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                               USART_CR1_RE))
 104:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 105:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
 106:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 107:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 108:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 109:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
 110:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 111:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 112:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART Interrupts mask */
 113:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define IT_MASK                   ((uint16_t)0x001F)
 114:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 115:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private macro -------------------------------------------------------------*/
 116:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private variables ---------------------------------------------------------*/
 117:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private function prototypes -----------------------------------------------*/
 118:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private functions ---------------------------------------------------------*/
 119:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 120:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Private_Functions
 121:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 122:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 123:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 124:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 125:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Initialization and Configuration functions 
 126:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 127:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 128:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 129:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                   Initialization and Configuration functions
 130:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 131:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 132:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to initialize the USART 
 133:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   in asynchronous and in synchronous modes.
 134:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    - For the asynchronous mode only these parameters can be configured: 
 135:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Baud Rate
 136:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Word Length 
 137:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Stop Bit
 138:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Parity: If the parity is enabled, then the MSB bit of the data written
 139:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****           in the data register is transmitted but is changed by the parity bit.
 140:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****           Depending on the frame length defined by the M bit (8-bits or 9-bits),
 141:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****           the possible USART frame formats are as listed in the following table:
 142:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+     
 143:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 144:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------------------|---------------------------------------|             
 145:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 146:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 147:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 148:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 149:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 150:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 151:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 152:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+            
 153:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Hardware flow control
 154:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Receiver/transmitter modes
 155:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 156:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART_Init() function follows the USART  asynchronous configuration procedure
 157:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   (details for the procedure are available in reference manual (RM0090)).
 158:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 159:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   - For the synchronous mode in addition to the asynchronous mode parameters these 
 160:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     parameters should be also configured:
 161:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART Clock Enabled
 162:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART polarity
 163:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART phase
 164:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART LastBit
 165:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 166:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   These parameters can be configured using the USART_ClockInit() function.
 167:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 168:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 169:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 170:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 171:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 172:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 173:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 174:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 175:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 176:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 177:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 178:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 179:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
  26              		.loc 1 179 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 08B5     		push	{r3, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
 180:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 181:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 182:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 183:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USARTx == USART1)
  35              		.loc 1 183 0
  36 0002 284B     		ldr	r3, .L8
  37 0004 9842     		cmp	r0, r3
  38 0006 08D1     		bne	.L2
 184:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 185:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  39              		.loc 1 185 0
  40 0008 1020     		movs	r0, #16
  41              	.LVL1:
  42 000a 0121     		movs	r1, #1
  43 000c FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  44              	.LVL2:
 186:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  45              		.loc 1 186 0
  46 0010 1020     		movs	r0, #16
  47 0012 0021     		movs	r1, #0
  48 0014 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  49              	.LVL3:
  50 0018 08BD     		pop	{r3, pc}
  51              	.LVL4:
  52              	.L2:
 187:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 188:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == USART2)
  53              		.loc 1 188 0
  54 001a 234B     		ldr	r3, .L8+4
  55 001c 9842     		cmp	r0, r3
  56 001e 0AD1     		bne	.L4
 189:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 190:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  57              		.loc 1 190 0
  58 0020 4FF40030 		mov	r0, #131072
  59              	.LVL5:
  60 0024 0121     		movs	r1, #1
  61 0026 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  62              	.LVL6:
 191:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  63              		.loc 1 191 0
  64 002a 4FF40030 		mov	r0, #131072
  65 002e 0021     		movs	r1, #0
  66 0030 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  67              	.LVL7:
  68 0034 08BD     		pop	{r3, pc}
  69              	.LVL8:
  70              	.L4:
 192:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 193:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == USART3)
  71              		.loc 1 193 0
  72 0036 1D4B     		ldr	r3, .L8+8
  73 0038 9842     		cmp	r0, r3
  74 003a 0AD1     		bne	.L5
 194:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 195:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  75              		.loc 1 195 0
  76 003c 4FF48020 		mov	r0, #262144
  77              	.LVL9:
  78 0040 0121     		movs	r1, #1
  79 0042 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  80              	.LVL10:
 196:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  81              		.loc 1 196 0
  82 0046 4FF48020 		mov	r0, #262144
  83 004a 0021     		movs	r1, #0
  84 004c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  85              	.LVL11:
  86 0050 08BD     		pop	{r3, pc}
  87              	.LVL12:
  88              	.L5:
 197:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }    
 198:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == UART4)
  89              		.loc 1 198 0
  90 0052 174B     		ldr	r3, .L8+12
  91 0054 9842     		cmp	r0, r3
  92 0056 0AD1     		bne	.L6
 199:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 200:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
  93              		.loc 1 200 0
  94 0058 4FF40020 		mov	r0, #524288
  95              	.LVL13:
  96 005c 0121     		movs	r1, #1
  97 005e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  98              	.LVL14:
 201:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  99              		.loc 1 201 0
 100 0062 4FF40020 		mov	r0, #524288
 101 0066 0021     		movs	r1, #0
 102 0068 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 103              	.LVL15:
 104 006c 08BD     		pop	{r3, pc}
 105              	.LVL16:
 106              	.L6:
 202:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 203:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == UART5)
 107              		.loc 1 203 0
 108 006e 114B     		ldr	r3, .L8+16
 109 0070 9842     		cmp	r0, r3
 110 0072 0AD1     		bne	.L7
 204:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 205:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 111              		.loc 1 205 0
 112 0074 4FF48010 		mov	r0, #1048576
 113              	.LVL17:
 114 0078 0121     		movs	r1, #1
 115 007a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 116              	.LVL18:
 206:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 117              		.loc 1 206 0
 118 007e 4FF48010 		mov	r0, #1048576
 119 0082 0021     		movs	r1, #0
 120 0084 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 121              	.LVL19:
 122 0088 08BD     		pop	{r3, pc}
 123              	.LVL20:
 124              	.L7:
 207:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }     
 208:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 209:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 210:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     if (USARTx == USART6)
 125              		.loc 1 210 0
 126 008a 0B4B     		ldr	r3, .L8+20
 127 008c 9842     		cmp	r0, r3
 128 008e 07D1     		bne	.L1
 211:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     { 
 212:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 129              		.loc 1 212 0
 130 0090 2020     		movs	r0, #32
 131              	.LVL21:
 132 0092 0121     		movs	r1, #1
 133 0094 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 134              	.LVL22:
 213:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 135              		.loc 1 213 0
 136 0098 2020     		movs	r0, #32
 137 009a 0021     		movs	r1, #0
 138 009c FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 139              	.LVL23:
 140              	.L1:
 141 00a0 08BD     		pop	{r3, pc}
 142              	.L9:
 143 00a2 00BF     		.align	2
 144              	.L8:
 145 00a4 00100140 		.word	1073811456
 146 00a8 00440040 		.word	1073759232
 147 00ac 00480040 		.word	1073760256
 148 00b0 004C0040 		.word	1073761280
 149 00b4 00500040 		.word	1073762304
 150 00b8 00140140 		.word	1073812480
 151              		.cfi_endproc
 152              	.LFE110:
 154              		.align	2
 155              		.global	USART_Init
 156              		.thumb
 157              		.thumb_func
 159              	USART_Init:
 160              	.LFB111:
 214:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     }
 215:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 216:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 217:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 218:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 219:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 220:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         parameters in the USART_InitStruct .
 221:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 222:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 223:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
 224:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         the configuration information for the specified USART peripheral.
 225:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 226:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 227:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 161              		.loc 1 228 0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 16
 164              		@ frame_needed = 0, uses_anonymous_args = 0
 165              	.LVL24:
 166 00bc 30B5     		push	{r4, r5, lr}
 167              		.cfi_def_cfa_offset 12
 168              		.cfi_offset 4, -12
 169              		.cfi_offset 5, -8
 170              		.cfi_offset 14, -4
 171 00be 85B0     		sub	sp, sp, #20
 172              		.cfi_def_cfa_offset 32
 173 00c0 0446     		mov	r4, r0
 174 00c2 0D46     		mov	r5, r1
 175              	.LVL25:
 229:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00, apbclock = 0x00;
 230:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t integerdivider = 0x00;
 231:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t fractionaldivider = 0x00;
 232:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 233:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 234:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 235:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 236:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 237:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 238:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 239:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 240:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 241:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 242:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 243:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
 244:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 245:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 246:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
 247:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 248:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 249:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 250:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 176              		.loc 1 250 0
 177 00c4 038A     		ldrh	r3, [r0, #16]
 178 00c6 9BB2     		uxth	r3, r3
 179              	.LVL26:
 251:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 252:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear STOP[13:12] bits */
 253:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 180              		.loc 1 253 0
 181 00c8 23F44053 		bic	r3, r3, #12288
 182              	.LVL27:
 254:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 255:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
 256:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       Set STOP[13:12] bits according to USART_StopBits value */
 257:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 183              		.loc 1 257 0
 184 00cc CA88     		ldrh	r2, [r1, #6]
 185              	.LVL28:
 258:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 259:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 260:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 186              		.loc 1 260 0
 187 00ce 1343     		orrs	r3, r3, r2
 188              	.LVL29:
 189 00d0 0382     		strh	r3, [r0, #16]	@ movhi
 261:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 262:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 263:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR1;
 190              		.loc 1 263 0
 191 00d2 8289     		ldrh	r2, [r0, #12]
 192 00d4 92B2     		uxth	r2, r2
 193              	.LVL30:
 264:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 265:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 194              		.loc 1 266 0
 195 00d6 22F4B052 		bic	r2, r2, #5632
 196              	.LVL31:
 197 00da 22F00C02 		bic	r2, r2, #12
 198              	.LVL32:
 267:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 268:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Word Length, Parity and mode: 
 269:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      Set the M bits according to USART_WordLength value 
 270:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      Set PCE and PS bits according to USART_Parity value
 271:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      Set TE and RE bits according to USART_Mode value */
 272:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 199              		.loc 1 272 0
 200 00de 8888     		ldrh	r0, [r1, #4]
 201              	.LVL33:
 202 00e0 0B89     		ldrh	r3, [r1, #8]
 273:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 203              		.loc 1 273 0
 204 00e2 4989     		ldrh	r1, [r1, #10]
 205              	.LVL34:
 272:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 206              		.loc 1 272 0
 207 00e4 0343     		orrs	r3, r3, r0
 208 00e6 0B43     		orrs	r3, r3, r1
 209              	.LVL35:
 274:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 275:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR1 */
 276:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 = (uint16_t)tmpreg;
 210              		.loc 1 276 0
 211 00e8 1343     		orrs	r3, r3, r2
 212              	.LVL36:
 213 00ea A381     		strh	r3, [r4, #12]	@ movhi
 277:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 278:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 279:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR3;
 214              		.loc 1 279 0
 215 00ec A38A     		ldrh	r3, [r4, #20]
 216              	.LVL37:
 217 00ee 9BB2     		uxth	r3, r3
 218              	.LVL38:
 280:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 281:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear CTSE and RTSE bits */
 282:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 219              		.loc 1 282 0
 220 00f0 23F44073 		bic	r3, r3, #768
 221              	.LVL39:
 283:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 284:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART HFC : 
 285:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 286:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 222              		.loc 1 286 0
 223 00f4 AA89     		ldrh	r2, [r5, #12]
 224              	.LVL40:
 287:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 288:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR3 */
 289:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR3 = (uint16_t)tmpreg;
 225              		.loc 1 289 0
 226 00f6 1343     		orrs	r3, r3, r2
 227              	.LVL41:
 228 00f8 A382     		strh	r3, [r4, #20]	@ movhi
 290:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 291:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 292:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Baud Rate */
 293:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 229              		.loc 1 293 0
 230 00fa 6846     		mov	r0, sp
 231 00fc FFF7FEFF 		bl	RCC_GetClocksFreq
 232              	.LVL42:
 294:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 295:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx == USART1) || (USARTx == USART6))
 233              		.loc 1 295 0
 234 0100 1F4B     		ldr	r3, .L18
 235 0102 9C42     		cmp	r4, r3
 236 0104 03D0     		beq	.L11
 237              		.loc 1 295 0 is_stmt 0 discriminator 1
 238 0106 03F58063 		add	r3, r3, #1024
 239 010a 9C42     		cmp	r4, r3
 240 010c 01D1     		bne	.L12
 241              	.L11:
 296:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 297:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 242              		.loc 1 297 0 is_stmt 1
 243 010e 039A     		ldr	r2, [sp, #12]
 244              	.LVL43:
 245 0110 00E0     		b	.L13
 246              	.LVL44:
 247              	.L12:
 298:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 299:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 300:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 301:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 248              		.loc 1 301 0
 249 0112 029A     		ldr	r2, [sp, #8]
 250              	.LVL45:
 251              	.L13:
 302:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 303:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 304:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Determine the integer part */
 305:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 252              		.loc 1 305 0
 253 0114 A389     		ldrh	r3, [r4, #12]
 254 0116 1BB2     		sxth	r3, r3
 255 0118 002B     		cmp	r3, #0
 256 011a 08DA     		bge	.L14
 306:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 307:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 8 Samples */
 308:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 257              		.loc 1 308 0
 258 011c 02EB8202 		add	r2, r2, r2, lsl #2
 259              	.LVL46:
 260 0120 02EB8202 		add	r2, r2, r2, lsl #2
 261 0124 2B68     		ldr	r3, [r5]
 262 0126 5B00     		lsls	r3, r3, #1
 263 0128 B2FBF3F2 		udiv	r2, r2, r3
 264              	.LVL47:
 265 012c 07E0     		b	.L15
 266              	.LVL48:
 267              	.L14:
 309:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 310:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 311:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 312:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 16 Samples */
 313:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 268              		.loc 1 313 0
 269 012e 02EB8202 		add	r2, r2, r2, lsl #2
 270              	.LVL49:
 271 0132 02EB8202 		add	r2, r2, r2, lsl #2
 272 0136 2968     		ldr	r1, [r5]
 273 0138 8900     		lsls	r1, r1, #2
 274 013a B2FBF1F2 		udiv	r2, r2, r1
 275              	.LVL50:
 276              	.L15:
 314:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 315:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = (integerdivider / 100) << 4;
 277              		.loc 1 315 0
 278 013e 114B     		ldr	r3, .L18+4
 279 0140 A3FB0213 		umull	r1, r3, r3, r2
 280 0144 5B09     		lsrs	r3, r3, #5
 281              	.LVL51:
 316:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 317:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Determine the fractional part */
 318:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 282              		.loc 1 318 0
 283 0146 1801     		lsls	r0, r3, #4
 284              	.LVL52:
 285 0148 6421     		movs	r1, #100
 286 014a 03FB1123 		mls	r3, r3, r1, r2
 287              	.LVL53:
 319:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 320:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Implement the fractional part in the register */
 321:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 288              		.loc 1 321 0
 289 014e A189     		ldrh	r1, [r4, #12]
 290 0150 09B2     		sxth	r1, r1
 291 0152 0029     		cmp	r1, #0
 292 0154 08DA     		bge	.L16
 322:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 323:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 293              		.loc 1 323 0
 294 0156 DB00     		lsls	r3, r3, #3
 295              	.LVL54:
 296 0158 3233     		adds	r3, r3, #50
 297 015a 0A4D     		ldr	r5, .L18+4
 298              	.LVL55:
 299 015c A5FB0323 		umull	r2, r3, r5, r3
 300              	.LVL56:
 301 0160 C3F34213 		ubfx	r3, r3, #5, #3
 302 0164 0343     		orrs	r3, r3, r0
 303              	.LVL57:
 304 0166 07E0     		b	.L17
 305              	.LVL58:
 306              	.L16:
 324:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 325:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 326:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 327:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 307              		.loc 1 327 0
 308 0168 1B01     		lsls	r3, r3, #4
 309              	.LVL59:
 310 016a 3233     		adds	r3, r3, #50
 311 016c 054D     		ldr	r5, .L18+4
 312              	.LVL60:
 313 016e A5FB0313 		umull	r1, r3, r5, r3
 314 0172 C3F34313 		ubfx	r3, r3, #5, #4
 315 0176 0343     		orrs	r3, r3, r0
 316              	.LVL61:
 317              	.L17:
 328:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 329:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 330:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART BRR register */
 331:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->BRR = (uint16_t)tmpreg;
 318              		.loc 1 331 0
 319 0178 9BB2     		uxth	r3, r3
 320              	.LVL62:
 321 017a 2381     		strh	r3, [r4, #8]	@ movhi
 332:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 322              		.loc 1 332 0
 323 017c 05B0     		add	sp, sp, #20
 324              		@ sp needed
 325 017e 30BD     		pop	{r4, r5, pc}
 326              	.LVL63:
 327              	.L19:
 328              		.align	2
 329              	.L18:
 330 0180 00100140 		.word	1073811456
 331 0184 1F85EB51 		.word	1374389535
 332              		.cfi_endproc
 333              	.LFE111:
 335              		.align	2
 336              		.global	USART_StructInit
 337              		.thumb
 338              		.thumb_func
 340              	USART_StructInit:
 341              	.LFB112:
 333:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 334:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 335:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 336:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
 337:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         be initialized.
 338:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 339:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 340:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 341:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 342              		.loc 1 341 0
 343              		.cfi_startproc
 344              		@ args = 0, pretend = 0, frame = 0
 345              		@ frame_needed = 0, uses_anonymous_args = 0
 346              		@ link register save eliminated.
 347              	.LVL64:
 342:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* USART_InitStruct members default value */
 343:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 348              		.loc 1 343 0
 349 0188 4FF41653 		mov	r3, #9600
 350 018c 0360     		str	r3, [r0]
 344:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 351              		.loc 1 344 0
 352 018e 0023     		movs	r3, #0
 353 0190 8380     		strh	r3, [r0, #4]	@ movhi
 345:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 354              		.loc 1 345 0
 355 0192 C380     		strh	r3, [r0, #6]	@ movhi
 346:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 356              		.loc 1 346 0
 357 0194 0381     		strh	r3, [r0, #8]	@ movhi
 347:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 358              		.loc 1 347 0
 359 0196 0C22     		movs	r2, #12
 360 0198 4281     		strh	r2, [r0, #10]	@ movhi
 348:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 361              		.loc 1 348 0
 362 019a 8381     		strh	r3, [r0, #12]	@ movhi
 363 019c 7047     		bx	lr
 364              		.cfi_endproc
 365              	.LFE112:
 367 019e 00BF     		.align	2
 368              		.global	USART_ClockInit
 369              		.thumb
 370              		.thumb_func
 372              	USART_ClockInit:
 373              	.LFB113:
 349:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 350:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 351:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 352:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 353:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         specified parameters in the USART_ClockInitStruct .
 354:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
 355:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
 356:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         contains the configuration information for the specified  USART peripheral.
 357:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
 358:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 359:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 360:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 361:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 374              		.loc 1 361 0
 375              		.cfi_startproc
 376              		@ args = 0, pretend = 0, frame = 0
 377              		@ frame_needed = 0, uses_anonymous_args = 0
 378              		@ link register save eliminated.
 379              	.LVL65:
 380 01a0 30B4     		push	{r4, r5}
 381              		.cfi_def_cfa_offset 8
 382              		.cfi_offset 4, -8
 383              		.cfi_offset 5, -4
 384              	.LVL66:
 362:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00;
 363:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 364:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 365:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 366:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 367:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 368:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 369:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 370:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 371:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 385              		.loc 1 371 0
 386 01a2 028A     		ldrh	r2, [r0, #16]
 387 01a4 92B2     		uxth	r2, r2
 388              	.LVL67:
 372:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 373:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 389              		.loc 1 373 0
 390 01a6 22F47062 		bic	r2, r2, #3840
 391              	.LVL68:
 374:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 375:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 376:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 377:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 378:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 379:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 392              		.loc 1 379 0
 393 01aa 0D88     		ldrh	r5, [r1]
 394 01ac 4B88     		ldrh	r3, [r1, #2]
 380:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 395              		.loc 1 380 0
 396 01ae 8C88     		ldrh	r4, [r1, #4]
 397 01b0 C988     		ldrh	r1, [r1, #6]
 398              	.LVL69:
 399 01b2 2B43     		orrs	r3, r3, r5
 400 01b4 2343     		orrs	r3, r3, r4
 401 01b6 0B43     		orrs	r3, r3, r1
 402              	.LVL70:
 381:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 382:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 403              		.loc 1 382 0
 404 01b8 1343     		orrs	r3, r3, r2
 405              	.LVL71:
 406 01ba 0382     		strh	r3, [r0, #16]	@ movhi
 383:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 407              		.loc 1 383 0
 408 01bc 30BC     		pop	{r4, r5}
 409 01be 7047     		bx	lr
 410              		.cfi_endproc
 411              	.LFE113:
 413              		.align	2
 414              		.global	USART_ClockStructInit
 415              		.thumb
 416              		.thumb_func
 418              	USART_ClockStructInit:
 419              	.LFB114:
 384:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 385:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 386:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 387:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
 388:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         which will be initialized.
 389:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 390:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 391:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 392:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 420              		.loc 1 392 0
 421              		.cfi_startproc
 422              		@ args = 0, pretend = 0, frame = 0
 423              		@ frame_needed = 0, uses_anonymous_args = 0
 424              		@ link register save eliminated.
 425              	.LVL72:
 393:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* USART_ClockInitStruct members default value */
 394:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 426              		.loc 1 394 0
 427 01c0 0023     		movs	r3, #0
 428 01c2 0380     		strh	r3, [r0]	@ movhi
 395:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 429              		.loc 1 395 0
 430 01c4 4380     		strh	r3, [r0, #2]	@ movhi
 396:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 431              		.loc 1 396 0
 432 01c6 8380     		strh	r3, [r0, #4]	@ movhi
 397:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 433              		.loc 1 397 0
 434 01c8 C380     		strh	r3, [r0, #6]	@ movhi
 435 01ca 7047     		bx	lr
 436              		.cfi_endproc
 437              	.LFE114:
 439              		.align	2
 440              		.global	USART_Cmd
 441              		.thumb
 442              		.thumb_func
 444              	USART_Cmd:
 445              	.LFB115:
 398:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 399:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 400:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 401:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 402:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 403:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 404:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 405:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 406:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 407:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 408:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 409:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 446              		.loc 1 409 0
 447              		.cfi_startproc
 448              		@ args = 0, pretend = 0, frame = 0
 449              		@ frame_needed = 0, uses_anonymous_args = 0
 450              		@ link register save eliminated.
 451              	.LVL73:
 410:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 411:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 412:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 413:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 414:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 452              		.loc 1 414 0
 453 01cc 29B1     		cbz	r1, .L24
 415:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 416:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 417:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 454              		.loc 1 417 0
 455 01ce 8389     		ldrh	r3, [r0, #12]
 456 01d0 9BB2     		uxth	r3, r3
 457 01d2 43F40053 		orr	r3, r3, #8192
 458 01d6 8381     		strh	r3, [r0, #12]	@ movhi
 459 01d8 7047     		bx	lr
 460              	.L24:
 418:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 419:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 420:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 421:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 422:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 461              		.loc 1 422 0
 462 01da 8389     		ldrh	r3, [r0, #12]
 463 01dc 23F40053 		bic	r3, r3, #8192
 464 01e0 1B04     		lsls	r3, r3, #16
 465 01e2 1B0C     		lsrs	r3, r3, #16
 466 01e4 8381     		strh	r3, [r0, #12]	@ movhi
 467 01e6 7047     		bx	lr
 468              		.cfi_endproc
 469              	.LFE115:
 471              		.align	2
 472              		.global	USART_SetPrescaler
 473              		.thumb
 474              		.thumb_func
 476              	USART_SetPrescaler:
 477              	.LFB116:
 423:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 424:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 425:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 426:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 427:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the system clock prescaler.
 428:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 429:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 430:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock. 
 431:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   The function is used for IrDA mode with UART4 and UART5.   
 432:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 433:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 434:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 435:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** { 
 478              		.loc 1 435 0
 479              		.cfi_startproc
 480              		@ args = 0, pretend = 0, frame = 0
 481              		@ frame_needed = 0, uses_anonymous_args = 0
 482              		@ link register save eliminated.
 483              	.LVL74:
 436:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 437:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 438:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 439:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear the USART prescaler */
 440:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 484              		.loc 1 440 0
 485 01e8 038B     		ldrh	r3, [r0, #24]
 486 01ea 03F47F43 		and	r3, r3, #65280
 487 01ee 0383     		strh	r3, [r0, #24]	@ movhi
 441:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set the USART prescaler */
 442:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 488              		.loc 1 442 0
 489 01f0 038B     		ldrh	r3, [r0, #24]
 490 01f2 9BB2     		uxth	r3, r3
 491 01f4 1943     		orrs	r1, r1, r3
 492              	.LVL75:
 493 01f6 0183     		strh	r1, [r0, #24]	@ movhi
 494 01f8 7047     		bx	lr
 495              		.cfi_endproc
 496              	.LFE116:
 498 01fa 00BF     		.align	2
 499              		.global	USART_OverSampling8Cmd
 500              		.thumb
 501              		.thumb_func
 503              	USART_OverSampling8Cmd:
 504              	.LFB117:
 443:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 444:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 445:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 446:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 447:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   This function has to be called before calling USART_Init() function
 448:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         in order to have correct baudrate Divider value.
 449:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 450:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 451:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 452:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 453:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 454:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 455:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 456:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 505              		.loc 1 456 0
 506              		.cfi_startproc
 507              		@ args = 0, pretend = 0, frame = 0
 508              		@ frame_needed = 0, uses_anonymous_args = 0
 509              		@ link register save eliminated.
 510              	.LVL76:
 457:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 458:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 459:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 460:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 461:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 511              		.loc 1 461 0
 512 01fc 39B1     		cbz	r1, .L28
 462:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 463:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 464:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 513              		.loc 1 464 0
 514 01fe 8389     		ldrh	r3, [r0, #12]
 515 0200 6FEA4343 		mvn	r3, r3, lsl #17
 516 0204 6FEA5343 		mvn	r3, r3, lsr #17
 517 0208 9BB2     		uxth	r3, r3
 518 020a 8381     		strh	r3, [r0, #12]	@ movhi
 519 020c 7047     		bx	lr
 520              	.L28:
 465:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 466:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 467:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 468:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 469:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 521              		.loc 1 469 0
 522 020e 8389     		ldrh	r3, [r0, #12]
 523 0210 C3F30E03 		ubfx	r3, r3, #0, #15
 524 0214 8381     		strh	r3, [r0, #12]	@ movhi
 525 0216 7047     		bx	lr
 526              		.cfi_endproc
 527              	.LFE117:
 529              		.align	2
 530              		.global	USART_OneBitMethodCmd
 531              		.thumb
 532              		.thumb_func
 534              	USART_OneBitMethodCmd:
 535              	.LFB118:
 470:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 471:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }  
 472:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 473:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 474:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 475:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 476:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 477:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 478:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 479:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 480:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 481:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 482:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 536              		.loc 1 482 0
 537              		.cfi_startproc
 538              		@ args = 0, pretend = 0, frame = 0
 539              		@ frame_needed = 0, uses_anonymous_args = 0
 540              		@ link register save eliminated.
 541              	.LVL77:
 483:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 484:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 485:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 486:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 487:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 542              		.loc 1 487 0
 543 0218 29B1     		cbz	r1, .L31
 488:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 489:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 490:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 544              		.loc 1 490 0
 545 021a 838A     		ldrh	r3, [r0, #20]
 546 021c 9BB2     		uxth	r3, r3
 547 021e 43F40063 		orr	r3, r3, #2048
 548 0222 8382     		strh	r3, [r0, #20]	@ movhi
 549 0224 7047     		bx	lr
 550              	.L31:
 491:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 492:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 493:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 494:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 495:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 551              		.loc 1 495 0
 552 0226 838A     		ldrh	r3, [r0, #20]
 553 0228 23F40063 		bic	r3, r3, #2048
 554 022c 1B04     		lsls	r3, r3, #16
 555 022e 1B0C     		lsrs	r3, r3, #16
 556 0230 8382     		strh	r3, [r0, #20]	@ movhi
 557 0232 7047     		bx	lr
 558              		.cfi_endproc
 559              	.LFE118:
 561              		.align	2
 562              		.global	USART_SendData
 563              		.thumb
 564              		.thumb_func
 566              	USART_SendData:
 567              	.LFB119:
 496:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 497:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 498:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 499:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 500:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 501:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 502:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 503:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group2 Data transfers functions
 504:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Data transfers functions 
 505:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 506:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 507:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 508:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                             Data transfers functions
 509:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 510:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 511:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART data 
 512:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   transfers.
 513:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 514:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   During an USART reception, data shifts in least significant bit first through 
 515:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
 516:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   between the internal bus and the received shift register.
 517:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 518:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   When a transmission is taking place, a write instruction to the USART_DR register 
 519:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   stores the data in the TDR register and which is copied in the shift register 
 520:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   at the end of the current transmission.
 521:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 522:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The read access of the USART_DR register can be done using the USART_ReceiveData()
 523:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   function and returns the RDR buffered value. Whereas a write access to the USART_DR 
 524:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   can be done using USART_SendData() function and stores the written data into 
 525:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   TDR buffer.
 526:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 527:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 528:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 529:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 530:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 531:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 532:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 533:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 534:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 535:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  Data: the data to transmit.
 536:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 537:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 538:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 539:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 568              		.loc 1 539 0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 0
 571              		@ frame_needed = 0, uses_anonymous_args = 0
 572              		@ link register save eliminated.
 573              	.LVL78:
 540:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 541:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 542:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 543:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
 544:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Transmit Data */
 545:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->DR = (Data & (uint16_t)0x01FF);
 574              		.loc 1 545 0
 575 0234 C1F30801 		ubfx	r1, r1, #0, #9
 576              	.LVL79:
 577 0238 8180     		strh	r1, [r0, #4]	@ movhi
 578 023a 7047     		bx	lr
 579              		.cfi_endproc
 580              	.LFE119:
 582              		.align	2
 583              		.global	USART_ReceiveData
 584              		.thumb
 585              		.thumb_func
 587              	USART_ReceiveData:
 588              	.LFB120:
 546:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 547:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 548:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 549:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 550:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 551:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 552:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval The received data.
 553:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 554:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 555:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 589              		.loc 1 555 0
 590              		.cfi_startproc
 591              		@ args = 0, pretend = 0, frame = 0
 592              		@ frame_needed = 0, uses_anonymous_args = 0
 593              		@ link register save eliminated.
 594              	.LVL80:
 556:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 557:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 558:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 559:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Receive Data */
 560:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 595              		.loc 1 560 0
 596 023c 8088     		ldrh	r0, [r0, #4]
 597              	.LVL81:
 561:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 598              		.loc 1 561 0
 599 023e C0F30800 		ubfx	r0, r0, #0, #9
 600 0242 7047     		bx	lr
 601              		.cfi_endproc
 602              	.LFE120:
 604              		.align	2
 605              		.global	USART_SetAddress
 606              		.thumb
 607              		.thumb_func
 609              	USART_SetAddress:
 610              	.LFB121:
 562:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 563:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 564:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 565:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 566:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 567:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group3 MultiProcessor Communication functions
 568:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Multi-Processor Communication functions 
 569:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 570:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 571:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 572:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                     Multi-Processor Communication functions
 573:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 574:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 575:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 576:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   multiprocessor communication.
 577:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 578:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   For instance one of the USARTs can be the master, its TX output is connected to 
 579:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the RX input of the other USART. The others are slaves, their respective TX outputs 
 580:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   are logically ANDed together and connected to the RX input of the master.
 581:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 582:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART multiprocessor communication is possible through the following procedure:
 583:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
 584:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         or Mode receiver and hardware flow control values using the USART_Init()
 585:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function.
 586:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Configures the USART address using the USART_SetAddress() function.
 587:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
 588:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         using USART_WakeUpConfig() function only for the slaves.
 589:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Enable the USART using the USART_Cmd() function.
 590:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
 591:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 592:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART Slave exit from mute mode when receive the wake up condition.
 593:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 594:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 595:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 596:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 597:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 598:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 599:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the address of the USART node.
 600:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 601:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 602:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 603:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 604:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 605:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 606:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 611              		.loc 1 606 0
 612              		.cfi_startproc
 613              		@ args = 0, pretend = 0, frame = 0
 614              		@ frame_needed = 0, uses_anonymous_args = 0
 615              		@ link register save eliminated.
 616              	.LVL82:
 607:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 608:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 609:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 610:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
 611:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear the USART address */
 612:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 617              		.loc 1 612 0
 618 0244 038A     		ldrh	r3, [r0, #16]
 619 0246 23F00F03 		bic	r3, r3, #15
 620 024a 1B04     		lsls	r3, r3, #16
 621 024c 1B0C     		lsrs	r3, r3, #16
 622 024e 0382     		strh	r3, [r0, #16]	@ movhi
 613:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set the USART address node */
 614:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_Address;
 623              		.loc 1 614 0
 624 0250 038A     		ldrh	r3, [r0, #16]
 625 0252 9BB2     		uxth	r3, r3
 626 0254 1943     		orrs	r1, r1, r3
 627              	.LVL83:
 628 0256 0182     		strh	r1, [r0, #16]	@ movhi
 629 0258 7047     		bx	lr
 630              		.cfi_endproc
 631              	.LFE121:
 633 025a 00BF     		.align	2
 634              		.global	USART_ReceiverWakeUpCmd
 635              		.thumb
 636              		.thumb_func
 638              	USART_ReceiverWakeUpCmd:
 639              	.LFB122:
 615:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 616:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 617:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 618:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Determines if the USART is in mute mode or not.
 619:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 620:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 621:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART mute mode.
 622:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 623:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 624:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 625:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 626:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 640              		.loc 1 626 0
 641              		.cfi_startproc
 642              		@ args = 0, pretend = 0, frame = 0
 643              		@ frame_needed = 0, uses_anonymous_args = 0
 644              		@ link register save eliminated.
 645              	.LVL84:
 627:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 628:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 629:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 630:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 631:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 646              		.loc 1 631 0
 647 025c 29B1     		cbz	r1, .L37
 632:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 633:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 634:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_RWU;
 648              		.loc 1 634 0
 649 025e 8389     		ldrh	r3, [r0, #12]
 650 0260 9BB2     		uxth	r3, r3
 651 0262 43F00203 		orr	r3, r3, #2
 652 0266 8381     		strh	r3, [r0, #12]	@ movhi
 653 0268 7047     		bx	lr
 654              	.L37:
 635:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 636:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 637:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 638:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 639:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 655              		.loc 1 639 0
 656 026a 8389     		ldrh	r3, [r0, #12]
 657 026c 23F00203 		bic	r3, r3, #2
 658 0270 1B04     		lsls	r3, r3, #16
 659 0272 1B0C     		lsrs	r3, r3, #16
 660 0274 8381     		strh	r3, [r0, #12]	@ movhi
 661 0276 7047     		bx	lr
 662              		.cfi_endproc
 663              	.LFE122:
 665              		.align	2
 666              		.global	USART_WakeUpConfig
 667              		.thumb
 668              		.thumb_func
 670              	USART_WakeUpConfig:
 671              	.LFB123:
 640:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 641:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 642:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 643:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Selects the USART WakeUp method.
 644:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 645:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 646:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
 647:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 648:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
 649:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
 650:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 651:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 652:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
 653:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 672              		.loc 1 653 0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 0
 675              		@ frame_needed = 0, uses_anonymous_args = 0
 676              		@ link register save eliminated.
 677              	.LVL85:
 654:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 655:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 656:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 657:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 658:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 678              		.loc 1 658 0
 679 0278 8389     		ldrh	r3, [r0, #12]
 680 027a 23F40063 		bic	r3, r3, #2048
 681 027e 1B04     		lsls	r3, r3, #16
 682 0280 1B0C     		lsrs	r3, r3, #16
 683 0282 8381     		strh	r3, [r0, #12]	@ movhi
 659:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 684              		.loc 1 659 0
 685 0284 8389     		ldrh	r3, [r0, #12]
 686 0286 9BB2     		uxth	r3, r3
 687 0288 1943     		orrs	r1, r1, r3
 688              	.LVL86:
 689 028a 8181     		strh	r1, [r0, #12]	@ movhi
 690 028c 7047     		bx	lr
 691              		.cfi_endproc
 692              	.LFE123:
 694 028e 00BF     		.align	2
 695              		.global	USART_LINBreakDetectLengthConfig
 696              		.thumb
 697              		.thumb_func
 699              	USART_LINBreakDetectLengthConfig:
 700              	.LFB124:
 660:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 661:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 662:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 663:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 664:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 665:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 666:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group4 LIN mode functions
 667:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   LIN mode functions 
 668:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 669:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 670:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 671:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                 LIN mode functions
 672:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 673:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 674:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART LIN 
 675:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Mode communication.
 676:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 677:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
 678:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the LIN standard.
 679:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 680:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Only this LIN Feature is supported by the USART IP:
 681:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     - LIN Master Synchronous Break send capability and LIN slave break detection
 682:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       capability :  13-bit break generation and 10/11 bit break detection
 683:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 684:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 685:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART LIN Master transmitter communication is possible through the following procedure:
 686:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 687:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         Mode transmitter or Mode receiver and hardware flow control values using 
 688:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         the USART_Init() function.
 689:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Enable the USART using the USART_Cmd() function.
 690:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Enable the LIN mode using the USART_LINCmd() function.
 691:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Send the break character using USART_SendBreak() function.
 692:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 693:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART LIN Master receiver communication is possible through the following procedure:
 694:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 695:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         Mode transmitter or Mode receiver and hardware flow control values using 
 696:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         the USART_Init() function.
 697:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Enable the USART using the USART_Cmd() function.
 698:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
 699:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function.
 700:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Enable the LIN mode using the USART_LINCmd() function.
 701:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 702:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 703:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In LIN mode, the following bits must be kept cleared:
 704:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - CLKEN in the USART_CR2 register,
 705:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
 706:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 707:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 708:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 709:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 710:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 711:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 712:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the USART LIN Break detection length.
 713:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 714:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 715:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
 716:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 717:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
 718:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
 719:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 720:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 721:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
 722:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 701              		.loc 1 722 0
 702              		.cfi_startproc
 703              		@ args = 0, pretend = 0, frame = 0
 704              		@ frame_needed = 0, uses_anonymous_args = 0
 705              		@ link register save eliminated.
 706              	.LVL87:
 723:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 724:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 725:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
 726:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 727:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 707              		.loc 1 727 0
 708 0290 038A     		ldrh	r3, [r0, #16]
 709 0292 23F02003 		bic	r3, r3, #32
 710 0296 1B04     		lsls	r3, r3, #16
 711 0298 1B0C     		lsrs	r3, r3, #16
 712 029a 0382     		strh	r3, [r0, #16]	@ movhi
 728:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 713              		.loc 1 728 0
 714 029c 038A     		ldrh	r3, [r0, #16]
 715 029e 9BB2     		uxth	r3, r3
 716 02a0 1943     		orrs	r1, r1, r3
 717              	.LVL88:
 718 02a2 0182     		strh	r1, [r0, #16]	@ movhi
 719 02a4 7047     		bx	lr
 720              		.cfi_endproc
 721              	.LFE124:
 723 02a6 00BF     		.align	2
 724              		.global	USART_LINCmd
 725              		.thumb
 726              		.thumb_func
 728              	USART_LINCmd:
 729              	.LFB125:
 729:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 730:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 731:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 732:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
 733:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 734:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 735:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART LIN mode.
 736:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 737:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 738:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 739:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 740:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 730              		.loc 1 740 0
 731              		.cfi_startproc
 732              		@ args = 0, pretend = 0, frame = 0
 733              		@ frame_needed = 0, uses_anonymous_args = 0
 734              		@ link register save eliminated.
 735              	.LVL89:
 741:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 742:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 743:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 744:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 745:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 736              		.loc 1 745 0
 737 02a8 29B1     		cbz	r1, .L42
 746:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 747:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 748:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 738              		.loc 1 748 0
 739 02aa 038A     		ldrh	r3, [r0, #16]
 740 02ac 9BB2     		uxth	r3, r3
 741 02ae 43F48043 		orr	r3, r3, #16384
 742 02b2 0382     		strh	r3, [r0, #16]	@ movhi
 743 02b4 7047     		bx	lr
 744              	.L42:
 749:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 750:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 751:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 752:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 753:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 745              		.loc 1 753 0
 746 02b6 038A     		ldrh	r3, [r0, #16]
 747 02b8 23F48043 		bic	r3, r3, #16384
 748 02bc 1B04     		lsls	r3, r3, #16
 749 02be 1B0C     		lsrs	r3, r3, #16
 750 02c0 0382     		strh	r3, [r0, #16]	@ movhi
 751 02c2 7047     		bx	lr
 752              		.cfi_endproc
 753              	.LFE125:
 755              		.align	2
 756              		.global	USART_SendBreak
 757              		.thumb
 758              		.thumb_func
 760              	USART_SendBreak:
 761              	.LFB126:
 754:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 755:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 756:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 757:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 758:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Transmits break characters.
 759:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 760:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 761:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 762:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 763:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 764:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 762              		.loc 1 764 0
 763              		.cfi_startproc
 764              		@ args = 0, pretend = 0, frame = 0
 765              		@ frame_needed = 0, uses_anonymous_args = 0
 766              		@ link register save eliminated.
 767              	.LVL90:
 765:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 766:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 767:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 768:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Send break characters */
 769:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_CR1_SBK;
 768              		.loc 1 769 0
 769 02c4 8389     		ldrh	r3, [r0, #12]
 770 02c6 9BB2     		uxth	r3, r3
 771 02c8 43F00103 		orr	r3, r3, #1
 772 02cc 8381     		strh	r3, [r0, #12]	@ movhi
 773 02ce 7047     		bx	lr
 774              		.cfi_endproc
 775              	.LFE126:
 777              		.align	2
 778              		.global	USART_HalfDuplexCmd
 779              		.thumb
 780              		.thumb_func
 782              	USART_HalfDuplexCmd:
 783              	.LFB127:
 770:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 771:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 772:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 773:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 774:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 775:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 776:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group5 Halfduplex mode function
 777:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Half-duplex mode function 
 778:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 779:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 780:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 781:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                          Half-duplex mode function
 782:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 783:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 784:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 785:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Half-duplex communication.
 786:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 787:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART can be configured to follow a single-wire half-duplex protocol where 
 788:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the TX and RX lines are internally connected.
 789:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 790:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART Half duplex communication is possible through the following procedure:
 791:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
 792:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         or Mode receiver and hardware flow control values using the USART_Init()
 793:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function.
 794:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Configures the USART address using the USART_SetAddress() function.
 795:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Enable the USART using the USART_Cmd() function.
 796:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
 797:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 798:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 799:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note The RX pin is no longer used
 800:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In Half-duplex mode the following bits must be kept cleared:
 801:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - LINEN and CLKEN bits in the USART_CR2 register.
 802:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - SCEN and IREN bits in the USART_CR3 register.
 803:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 804:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 805:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 806:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 807:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 808:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 809:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
 810:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 811:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 812:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART Communication.
 813:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 814:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 815:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 816:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 817:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 784              		.loc 1 817 0
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 0
 787              		@ frame_needed = 0, uses_anonymous_args = 0
 788              		@ link register save eliminated.
 789              	.LVL91:
 818:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 819:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 820:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 821:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 822:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 790              		.loc 1 822 0
 791 02d0 29B1     		cbz	r1, .L46
 823:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 824:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 825:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 792              		.loc 1 825 0
 793 02d2 838A     		ldrh	r3, [r0, #20]
 794 02d4 9BB2     		uxth	r3, r3
 795 02d6 43F00803 		orr	r3, r3, #8
 796 02da 8382     		strh	r3, [r0, #20]	@ movhi
 797 02dc 7047     		bx	lr
 798              	.L46:
 826:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 827:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 828:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 829:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 830:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 799              		.loc 1 830 0
 800 02de 838A     		ldrh	r3, [r0, #20]
 801 02e0 23F00803 		bic	r3, r3, #8
 802 02e4 1B04     		lsls	r3, r3, #16
 803 02e6 1B0C     		lsrs	r3, r3, #16
 804 02e8 8382     		strh	r3, [r0, #20]	@ movhi
 805 02ea 7047     		bx	lr
 806              		.cfi_endproc
 807              	.LFE127:
 809              		.align	2
 810              		.global	USART_SetGuardTime
 811              		.thumb
 812              		.thumb_func
 814              	USART_SetGuardTime:
 815              	.LFB128:
 831:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 832:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 833:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 834:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 835:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 836:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 837:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 838:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 839:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group6 Smartcard mode functions
 840:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Smartcard mode functions 
 841:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 842:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 843:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 844:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                Smartcard mode functions
 845:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 846:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 847:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 848:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Smartcard communication.
 849:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 850:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The Smartcard interface is designed to support asynchronous protocol Smartcards as
 851:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   defined in the ISO 7816-3 standard.
 852:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 853:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART can provide a clock to the smartcard through the SCLK output.
 854:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In smartcard mode, SCLK is not associated to the communication but is simply derived 
 855:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   from the internal peripheral input clock through a 5-bit prescaler.
 856:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 857:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Smartcard communication is possible through the following procedure:
 858:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
 859:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
 860:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Program the USART clock using the USART_ClockInit() function as following:
 861:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART Clock enabled
 862:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART CPOL Low
 863:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART CPHA on first edge
 864:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART Last Bit Clock Enabled
 865:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Program the Smartcard interface using the USART_Init() function as following:
 866:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Word Length = 9 Bits
 867:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - 1.5 Stop Bit
 868:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Even parity
 869:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - BaudRate = 12096 baud
 870:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Hardware flow control disabled (RTS and CTS signals)
 871:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Tx and Rx enabled
 872:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
 873:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function
 874:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. Enable the USART using the USART_Cmd() function.
 875:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
 876:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
 877:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 878:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Please refer to the ISO 7816-3 specification for more details.
 879:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 880:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 881:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
 882:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       to use 1.5 stop bits for both transmitting and receiving to avoid switching 
 883:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       between the two configurations.
 884:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In smartcard mode, the following bits must be kept cleared:
 885:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - LINEN bit in the USART_CR2 register.
 886:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - HDSEL and IREN bits in the USART_CR3 register.
 887:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note Smartcard mode is available on USART peripherals only (not available on UART4 
 888:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       and UART5 peripherals).
 889:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 890:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 891:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 892:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 893:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 894:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 895:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the specified USART guard time.
 896:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 897:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 898:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_GuardTime: specifies the guard time.   
 899:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 900:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 901:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
 902:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {    
 816              		.loc 1 902 0
 817              		.cfi_startproc
 818              		@ args = 0, pretend = 0, frame = 0
 819              		@ frame_needed = 0, uses_anonymous_args = 0
 820              		@ link register save eliminated.
 821              	.LVL92:
 903:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 904:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 905:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 906:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear the USART Guard time */
 907:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 822              		.loc 1 907 0
 823 02ec 038B     		ldrh	r3, [r0, #24]
 824 02ee DBB2     		uxtb	r3, r3
 825 02f0 0383     		strh	r3, [r0, #24]	@ movhi
 908:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set the USART guard time */
 909:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 826              		.loc 1 909 0
 827 02f2 038B     		ldrh	r3, [r0, #24]
 828 02f4 9BB2     		uxth	r3, r3
 829 02f6 43EA0121 		orr	r1, r3, r1, lsl #8
 830              	.LVL93:
 831 02fa 0183     		strh	r1, [r0, #24]	@ movhi
 832 02fc 7047     		bx	lr
 833              		.cfi_endproc
 834              	.LFE128:
 836 02fe 00BF     		.align	2
 837              		.global	USART_SmartCardCmd
 838              		.thumb
 839              		.thumb_func
 841              	USART_SmartCardCmd:
 842              	.LFB129:
 910:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 911:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 912:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 913:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
 914:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 915:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 916:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the Smart Card mode.
 917:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.      
 918:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 919:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 920:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 921:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 843              		.loc 1 921 0
 844              		.cfi_startproc
 845              		@ args = 0, pretend = 0, frame = 0
 846              		@ frame_needed = 0, uses_anonymous_args = 0
 847              		@ link register save eliminated.
 848              	.LVL94:
 922:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 923:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 924:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 925:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 849              		.loc 1 925 0
 850 0300 29B1     		cbz	r1, .L50
 926:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 927:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 928:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 851              		.loc 1 928 0
 852 0302 838A     		ldrh	r3, [r0, #20]
 853 0304 9BB2     		uxth	r3, r3
 854 0306 43F02003 		orr	r3, r3, #32
 855 030a 8382     		strh	r3, [r0, #20]	@ movhi
 856 030c 7047     		bx	lr
 857              	.L50:
 929:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 930:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 931:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 932:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 933:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 858              		.loc 1 933 0
 859 030e 838A     		ldrh	r3, [r0, #20]
 860 0310 23F02003 		bic	r3, r3, #32
 861 0314 1B04     		lsls	r3, r3, #16
 862 0316 1B0C     		lsrs	r3, r3, #16
 863 0318 8382     		strh	r3, [r0, #20]	@ movhi
 864 031a 7047     		bx	lr
 865              		.cfi_endproc
 866              	.LFE129:
 868              		.align	2
 869              		.global	USART_SmartCardNACKCmd
 870              		.thumb
 871              		.thumb_func
 873              	USART_SmartCardNACKCmd:
 874              	.LFB130:
 934:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 935:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 936:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 937:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 938:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables NACK transmission.
 939:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 940:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 941:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the NACK transmission.
 942:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
 943:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 944:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 945:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 946:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 875              		.loc 1 946 0
 876              		.cfi_startproc
 877              		@ args = 0, pretend = 0, frame = 0
 878              		@ frame_needed = 0, uses_anonymous_args = 0
 879              		@ link register save eliminated.
 880              	.LVL95:
 947:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 948:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx)); 
 949:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 950:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 881              		.loc 1 950 0
 882 031c 29B1     		cbz	r1, .L53
 951:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 952:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 953:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 883              		.loc 1 953 0
 884 031e 838A     		ldrh	r3, [r0, #20]
 885 0320 9BB2     		uxth	r3, r3
 886 0322 43F01003 		orr	r3, r3, #16
 887 0326 8382     		strh	r3, [r0, #20]	@ movhi
 888 0328 7047     		bx	lr
 889              	.L53:
 954:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 955:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 956:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 957:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 958:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 890              		.loc 1 958 0
 891 032a 838A     		ldrh	r3, [r0, #20]
 892 032c 23F01003 		bic	r3, r3, #16
 893 0330 1B04     		lsls	r3, r3, #16
 894 0332 1B0C     		lsrs	r3, r3, #16
 895 0334 8382     		strh	r3, [r0, #20]	@ movhi
 896 0336 7047     		bx	lr
 897              		.cfi_endproc
 898              	.LFE130:
 900              		.align	2
 901              		.global	USART_IrDAConfig
 902              		.thumb
 903              		.thumb_func
 905              	USART_IrDAConfig:
 906              	.LFB131:
 959:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 960:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 961:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 962:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 963:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 964:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 965:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 966:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group7 IrDA mode functions
 967:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   IrDA mode functions 
 968:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 969:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 970:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 971:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                 IrDA mode functions
 972:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 973:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 974:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 975:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   IrDA communication.
 976:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 977:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
 978:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
 979:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
 980:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   While receiving data, transmission should be avoided as the data to be transmitted
 981:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   could be corrupted.
 982:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 983:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   IrDA communication is possible through the following procedure:
 984:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
 985:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         modes and hardware flow control values using the USART_Init() function.
 986:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Enable the USART using the USART_Cmd() function.
 987:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Configures the IrDA pulse width by configuring the prescaler using  
 988:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         the USART_SetPrescaler() function.
 989:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
 990:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         using the USART_IrDAConfig() function.
 991:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. Enable the IrDA using the USART_IrDACmd() function.
 992:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 993:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note A pulse of width less than two and greater than one PSC period(s) may or may
 994:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       not be rejected.
 995:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note The receiver set up time should be managed by software. The IrDA physical layer
 996:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       specification specifies a minimum of 10 ms delay between transmission and 
 997:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       reception (IrDA is a half duplex protocol).
 998:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In IrDA mode, the following bits must be kept cleared:
 999:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - LINEN, STOP and CLKEN bits in the USART_CR2 register.
1000:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - SCEN and HDSEL bits in the USART_CR3 register.
1001:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1002:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
1003:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
1004:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1005:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1006:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1007:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Configures the USART's IrDA interface.
1008:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1009:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1010:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1011:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1012:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_LowPower
1013:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_Normal
1014:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1015:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1016:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
1017:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 907              		.loc 1 1017 0
 908              		.cfi_startproc
 909              		@ args = 0, pretend = 0, frame = 0
 910              		@ frame_needed = 0, uses_anonymous_args = 0
 911              		@ link register save eliminated.
 912              	.LVL96:
1018:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1019:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1020:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1021:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1022:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 913              		.loc 1 1022 0
 914 0338 838A     		ldrh	r3, [r0, #20]
 915 033a 23F00403 		bic	r3, r3, #4
 916 033e 1B04     		lsls	r3, r3, #16
 917 0340 1B0C     		lsrs	r3, r3, #16
 918 0342 8382     		strh	r3, [r0, #20]	@ movhi
1023:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 919              		.loc 1 1023 0
 920 0344 838A     		ldrh	r3, [r0, #20]
 921 0346 9BB2     		uxth	r3, r3
 922 0348 1943     		orrs	r1, r1, r3
 923              	.LVL97:
 924 034a 8182     		strh	r1, [r0, #20]	@ movhi
 925 034c 7047     		bx	lr
 926              		.cfi_endproc
 927              	.LFE131:
 929 034e 00BF     		.align	2
 930              		.global	USART_IrDACmd
 931              		.thumb
 932              		.thumb_func
 934              	USART_IrDACmd:
 935              	.LFB132:
1024:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1025:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1026:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1027:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
1028:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1029:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1030:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the IrDA mode.
1031:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1032:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1033:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1034:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1035:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 936              		.loc 1 1035 0
 937              		.cfi_startproc
 938              		@ args = 0, pretend = 0, frame = 0
 939              		@ frame_needed = 0, uses_anonymous_args = 0
 940              		@ link register save eliminated.
 941              	.LVL98:
1036:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1037:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1038:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1039:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1040:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 942              		.loc 1 1040 0
 943 0350 29B1     		cbz	r1, .L57
1041:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1042:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1043:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
 944              		.loc 1 1043 0
 945 0352 838A     		ldrh	r3, [r0, #20]
 946 0354 9BB2     		uxth	r3, r3
 947 0356 43F00203 		orr	r3, r3, #2
 948 035a 8382     		strh	r3, [r0, #20]	@ movhi
 949 035c 7047     		bx	lr
 950              	.L57:
1044:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1045:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1046:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1047:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
1048:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 951              		.loc 1 1048 0
 952 035e 838A     		ldrh	r3, [r0, #20]
 953 0360 23F00203 		bic	r3, r3, #2
 954 0364 1B04     		lsls	r3, r3, #16
 955 0366 1B0C     		lsrs	r3, r3, #16
 956 0368 8382     		strh	r3, [r0, #20]	@ movhi
 957 036a 7047     		bx	lr
 958              		.cfi_endproc
 959              	.LFE132:
 961              		.align	2
 962              		.global	USART_DMACmd
 963              		.thumb
 964              		.thumb_func
 966              	USART_DMACmd:
 967              	.LFB133:
1049:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1050:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1051:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1052:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1053:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
1054:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1055:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1056:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group8 DMA transfers management functions
1057:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   DMA transfers management functions
1058:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
1059:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
1060:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
1061:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                       DMA transfers management functions
1062:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
1063:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1064:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
1065:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
1066:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1067:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1068:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1069:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1070:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1071:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1072:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1073:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1074:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Tx: USART DMA transmit request
1075:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Rx: USART DMA receive request
1076:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1077:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.   
1078:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1079:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1080:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
1081:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 968              		.loc 1 1081 0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 0
 971              		@ frame_needed = 0, uses_anonymous_args = 0
 972              		@ link register save eliminated.
 973              	.LVL99:
1082:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1083:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1084:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1085:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1086:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1087:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 974              		.loc 1 1087 0
 975 036c 22B1     		cbz	r2, .L60
1088:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1089:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1090:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1091:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 976              		.loc 1 1091 0
 977 036e 838A     		ldrh	r3, [r0, #20]
 978 0370 9BB2     		uxth	r3, r3
 979 0372 1943     		orrs	r1, r1, r3
 980              	.LVL100:
 981 0374 8182     		strh	r1, [r0, #20]	@ movhi
 982 0376 7047     		bx	lr
 983              	.LVL101:
 984              	.L60:
1092:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1093:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1094:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1095:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1096:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1097:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 985              		.loc 1 1097 0
 986 0378 838A     		ldrh	r3, [r0, #20]
 987 037a C943     		mvns	r1, r1
 988              	.LVL102:
 989 037c 89B2     		uxth	r1, r1
 990 037e 1940     		ands	r1, r1, r3
 991 0380 8182     		strh	r1, [r0, #20]	@ movhi
 992 0382 7047     		bx	lr
 993              		.cfi_endproc
 994              	.LFE133:
 996              		.align	2
 997              		.global	USART_ITConfig
 998              		.thumb
 999              		.thumb_func
 1001              	USART_ITConfig:
 1002              	.LFB134:
1098:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1099:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1100:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1101:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1102:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
1103:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1104:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1105:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group9 Interrupts and flags management functions
1106:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Interrupts and flags management functions 
1107:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
1108:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
1109:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
1110:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                    Interrupts and flags management functions
1111:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
1112:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1113:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to configure the USART 
1114:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Interrupts sources, DMA channels requests and check or clear the flags or 
1115:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   pending bits status.
1116:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The user should identify which mode will be used in his application to manage 
1117:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the communication: Polling mode, Interrupt mode or DMA mode. 
1118:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1119:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Polling Mode
1120:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   =============
1121:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In Polling Mode, the SPI communication can be managed by 10 flags:
1122:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
1123:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
1124:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. USART_FLAG_TC : to indicate the status of the transmit operation
1125:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
1126:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. USART_FLAG_CTS : to indicate the status of the nCTS input
1127:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. USART_FLAG_LBD : to indicate the status of the LIN break detection
1128:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. USART_FLAG_NE : to indicate if a noise error occur
1129:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. USART_FLAG_FE : to indicate if a frame error occur
1130:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      9. USART_FLAG_PE : to indicate if a parity error occur
1131:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      10. USART_FLAG_ORE : to indicate if an Overrun error occur
1132:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1133:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In this Mode it is advised to use the following functions:
1134:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1135:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1136:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1137:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Interrupt Mode
1138:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ===============
1139:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
1140:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   and 10 pending bits: 
1141:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1142:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Pending Bits:
1143:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ------------- 
1144:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_IT_TXE : to indicate the status of the transmit buffer register
1145:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_IT_RXNE : to indicate the status of the receive buffer register
1146:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. USART_IT_TC : to indicate the status of the transmit operation
1147:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. USART_IT_IDLE : to indicate the status of the Idle Line             
1148:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. USART_IT_CTS : to indicate the status of the nCTS input
1149:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. USART_IT_LBD : to indicate the status of the LIN break detection
1150:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. USART_IT_NE : to indicate if a noise error occur
1151:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. USART_IT_FE : to indicate if a frame error occur
1152:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      9. USART_IT_PE : to indicate if a parity error occur
1153:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      10. USART_IT_ORE : to indicate if an Overrun error occur
1154:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1155:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Interrupt Source:
1156:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   -----------------
1157:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
1158:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                        interrupt. 
1159:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
1160:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                         empty interrupt.
1161:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
1162:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                        interrupt. 
1163:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
1164:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
1165:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
1166:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                        interrupt. 
1167:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
1168:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
1169:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1170:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note Some parameters are coded in order to use them as interrupt source or as pending bits.
1171:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1172:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In this Mode it is advised to use the following functions:
1173:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
1174:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
1175:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
1176:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1177:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   DMA Mode
1178:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ========
1179:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
1180:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
1181:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
1182:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1183:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In this Mode it is advised to use the following function:
1184:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
1185:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1186:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
1187:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
1188:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1189:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1190:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1191:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1192:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1193:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1194:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1195:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1196:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt
1197:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1198:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1199:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1200:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1201:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1202:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1203:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1204:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1205:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1206:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1207:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1208:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
1209:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1003              		.loc 1 1209 0
 1004              		.cfi_startproc
 1005              		@ args = 0, pretend = 0, frame = 0
 1006              		@ frame_needed = 0, uses_anonymous_args = 0
 1007              		@ link register save eliminated.
 1008              	.LVL103:
 1009 0384 10B4     		push	{r4}
 1010              		.cfi_def_cfa_offset 4
 1011              		.cfi_offset 4, -4
 1012              	.LVL104:
1210:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
1211:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t usartxbase = 0x00;
1212:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1213:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1214:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1215:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1216:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1217:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1218:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1219:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1220:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1221:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1222:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1223:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartxbase = (uint32_t)USARTx;
1224:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1225:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the USART register index */
1226:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1013              		.loc 1 1226 0
 1014 0386 C1F34213 		ubfx	r3, r1, #5, #3
 1015              	.LVL105:
1227:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1229:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itpos = USART_IT & IT_MASK;
 1016              		.loc 1 1229 0
 1017 038a 01F01F01 		and	r1, r1, #31
 1018              	.LVL106:
1230:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 1019              		.loc 1 1230 0
 1020 038e 0124     		movs	r4, #1
 1021 0390 04FA01F1 		lsl	r1, r4, r1
 1022              	.LVL107:
1231:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1232:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 1023              		.loc 1 1232 0
 1024 0394 A342     		cmp	r3, r4
 1025 0396 01D1     		bne	.L63
1233:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1234:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     usartxbase += 0x0C;
 1026              		.loc 1 1234 0
 1027 0398 0C30     		adds	r0, r0, #12
 1028              	.LVL108:
 1029 039a 04E0     		b	.L64
 1030              	.LVL109:
 1031              	.L63:
1235:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1236:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 1032              		.loc 1 1236 0
 1033 039c 022B     		cmp	r3, #2
 1034 039e 01D1     		bne	.L65
1237:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1238:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     usartxbase += 0x10;
 1035              		.loc 1 1238 0
 1036 03a0 1030     		adds	r0, r0, #16
 1037              	.LVL110:
 1038 03a2 00E0     		b	.L64
 1039              	.LVL111:
 1040              	.L65:
1239:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1240:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* The IT is in CR3 register */
1241:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1242:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     usartxbase += 0x14; 
 1041              		.loc 1 1242 0
 1042 03a4 1430     		adds	r0, r0, #20
 1043              	.LVL112:
 1044              	.L64:
1243:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1244:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1045              		.loc 1 1244 0
 1046 03a6 1AB1     		cbz	r2, .L66
1245:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1246:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 1047              		.loc 1 1246 0
 1048 03a8 0368     		ldr	r3, [r0]
 1049              	.LVL113:
 1050 03aa 1943     		orrs	r1, r1, r3
 1051              	.LVL114:
 1052 03ac 0160     		str	r1, [r0]
 1053 03ae 03E0     		b	.L62
 1054              	.LVL115:
 1055              	.L66:
1247:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1248:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1249:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1250:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 1056              		.loc 1 1250 0
 1057 03b0 0368     		ldr	r3, [r0]
 1058              	.LVL116:
 1059 03b2 23EA0101 		bic	r1, r3, r1
 1060              	.LVL117:
 1061 03b6 0160     		str	r1, [r0]
 1062              	.L62:
1251:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1252:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1063              		.loc 1 1252 0
 1064 03b8 5DF8044B 		ldr	r4, [sp], #4
 1065 03bc 7047     		bx	lr
 1066              		.cfi_endproc
 1067              	.LFE134:
 1069 03be 00BF     		.align	2
 1070              		.global	USART_GetFlagStatus
 1071              		.thumb
 1072              		.thumb_func
 1074              	USART_GetFlagStatus:
 1075              	.LFB135:
1253:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1254:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1255:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1256:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1257:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1258:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1259:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1260:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
1261:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag
1262:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TXE:  Transmit data register empty flag
1263:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag
1264:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag
1265:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_IDLE: Idle Line detection flag
1266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_ORE:  OverRun Error flag
1267:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_NE:   Noise Error flag
1268:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_FE:   Framing Error flag
1269:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_PE:   Parity Error flag
1270:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1271:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1272:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1273:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1076              		.loc 1 1273 0
 1077              		.cfi_startproc
 1078              		@ args = 0, pretend = 0, frame = 0
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080              		@ link register save eliminated.
 1081              	.LVL118:
1274:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   FlagStatus bitstatus = RESET;
1275:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1276:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1277:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1278:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1279:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1280:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_FLAG == USART_FLAG_CTS)
1281:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1282:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1283:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1284:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1285:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 1082              		.loc 1 1285 0
 1083 03c0 0388     		ldrh	r3, [r0]
 1084 03c2 1942     		tst	r1, r3
 1085 03c4 01D0     		beq	.L70
1286:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1287:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = SET;
 1086              		.loc 1 1287 0
 1087 03c6 0120     		movs	r0, #1
 1088              	.LVL119:
 1089 03c8 7047     		bx	lr
 1090              	.LVL120:
 1091              	.L70:
1288:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1289:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1290:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1291:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = RESET;
 1092              		.loc 1 1291 0
 1093 03ca 0020     		movs	r0, #0
 1094              	.LVL121:
1292:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1293:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   return bitstatus;
1294:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1095              		.loc 1 1294 0
 1096 03cc 7047     		bx	lr
 1097              		.cfi_endproc
 1098              	.LFE135:
 1100 03ce 00BF     		.align	2
 1101              		.global	USART_ClearFlag
 1102              		.thumb
 1103              		.thumb_func
 1105              	USART_ClearFlag:
 1106              	.LFB136:
1295:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1296:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1297:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's pending flags.
1298:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1299:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1300:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
1301:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1302:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
1303:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag.
1304:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag.
1305:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
1306:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *   
1307:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1308:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) flags are cleared by software 
1309:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
1310:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          followed by a read operation to USART_DR register (USART_ReceiveData()).
1311:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   RXNE flag can be also cleared by a read to the USART_DR register 
1312:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1313:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TC flag can be also cleared by software sequence: a read operation to 
1314:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
1315:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          to USART_DR register (USART_SendData()).
1316:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TXE flag is cleared only by a write to the USART_DR register 
1317:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1318:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *   
1319:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1320:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1321:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1322:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1107              		.loc 1 1322 0
 1108              		.cfi_startproc
 1109              		@ args = 0, pretend = 0, frame = 0
 1110              		@ frame_needed = 0, uses_anonymous_args = 0
 1111              		@ link register save eliminated.
 1112              	.LVL122:
1323:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1324:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1325:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
1326:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1327:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1328:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
1329:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1330:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1331:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1332:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****        
1333:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~USART_FLAG;
 1113              		.loc 1 1333 0
 1114 03d0 C943     		mvns	r1, r1
 1115              	.LVL123:
 1116 03d2 89B2     		uxth	r1, r1
 1117 03d4 0180     		strh	r1, [r0]	@ movhi
 1118 03d6 7047     		bx	lr
 1119              		.cfi_endproc
 1120              	.LFE136:
 1122              		.align	2
 1123              		.global	USART_GetITStatus
 1124              		.thumb
 1125              		.thumb_func
 1127              	USART_GetITStatus:
 1128              	.LFB137:
1334:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1335:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1336:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1337:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
1338:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1339:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1340:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
1341:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1342:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1343:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1344:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1345:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1346:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1347:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1348:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
1349:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
1350:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_NE:   Noise Error interrupt
1351:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_FE:   Framing Error interrupt
1352:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1353:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
1354:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1355:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
1356:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1129              		.loc 1 1356 0
 1130              		.cfi_startproc
 1131              		@ args = 0, pretend = 0, frame = 0
 1132              		@ frame_needed = 0, uses_anonymous_args = 0
 1133              		@ link register save eliminated.
 1134              	.LVL124:
 1135 03d8 10B4     		push	{r4}
 1136              		.cfi_def_cfa_offset 4
 1137              		.cfi_offset 4, -4
 1138              	.LVL125:
1357:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
1358:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ITStatus bitstatus = RESET;
1359:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1360:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1361:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
1362:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1363:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */ 
1364:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1365:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1366:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1367:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1368:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1369:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the USART register index */
1370:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1139              		.loc 1 1370 0
 1140 03da C1F34213 		ubfx	r3, r1, #5, #3
 1141              	.LVL126:
1371:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1372:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = USART_IT & IT_MASK;
 1142              		.loc 1 1372 0
 1143 03de 01F01F02 		and	r2, r1, #31
 1144              	.LVL127:
1373:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 1145              		.loc 1 1373 0
 1146 03e2 0124     		movs	r4, #1
 1147 03e4 9440     		lsls	r4, r4, r2
 1148              	.LVL128:
1374:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1375:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 1149              		.loc 1 1375 0
 1150 03e6 012B     		cmp	r3, #1
 1151 03e8 03D1     		bne	.L73
1376:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1377:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR1;
 1152              		.loc 1 1377 0
 1153 03ea 8289     		ldrh	r2, [r0, #12]
 1154 03ec 92B2     		uxth	r2, r2
 1155 03ee 2240     		ands	r2, r2, r4
 1156              	.LVL129:
 1157 03f0 08E0     		b	.L74
 1158              	.LVL130:
 1159              	.L73:
1378:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1379:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 1160              		.loc 1 1379 0
 1161 03f2 022B     		cmp	r3, #2
 1162 03f4 03D1     		bne	.L75
1380:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1381:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR2;
 1163              		.loc 1 1381 0
 1164 03f6 028A     		ldrh	r2, [r0, #16]
 1165 03f8 92B2     		uxth	r2, r2
 1166 03fa 2240     		ands	r2, r2, r4
 1167              	.LVL131:
 1168 03fc 02E0     		b	.L74
 1169              	.LVL132:
 1170              	.L75:
1382:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1383:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* The IT  is in CR3 register */
1384:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1385:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR3;
 1171              		.loc 1 1385 0
 1172 03fe 828A     		ldrh	r2, [r0, #20]
 1173 0400 92B2     		uxth	r2, r2
 1174 0402 2240     		ands	r2, r2, r4
 1175              	.LVL133:
 1176              	.L74:
1386:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1387:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1388:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 1177              		.loc 1 1388 0
 1178 0404 090A     		lsrs	r1, r1, #8
 1179              	.LVL134:
1389:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 1180              		.loc 1 1389 0
 1181 0406 0123     		movs	r3, #1
 1182              	.LVL135:
 1183 0408 03FA01F1 		lsl	r1, r3, r1
 1184              	.LVL136:
1390:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos &= USARTx->SR;
 1185              		.loc 1 1390 0
 1186 040c 0388     		ldrh	r3, [r0]
 1187 040e 9BB2     		uxth	r3, r3
 1188 0410 1940     		ands	r1, r1, r3
 1189              	.LVL137:
1391:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 1190              		.loc 1 1391 0
 1191 0412 12B1     		cbz	r2, .L77
 1192              		.loc 1 1391 0 is_stmt 0 discriminator 1
 1193 0414 19B9     		cbnz	r1, .L78
1392:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1393:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = SET;
1394:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1395:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1396:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1397:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = RESET;
 1194              		.loc 1 1397 0 is_stmt 1
 1195 0416 0020     		movs	r0, #0
 1196              	.LVL138:
 1197 0418 02E0     		b	.L76
 1198              	.LVL139:
 1199              	.L77:
 1200 041a 0020     		movs	r0, #0
 1201              	.LVL140:
 1202 041c 00E0     		b	.L76
 1203              	.LVL141:
 1204              	.L78:
1393:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = SET;
 1205              		.loc 1 1393 0
 1206 041e 0120     		movs	r0, #1
 1207              	.LVL142:
 1208              	.L76:
1398:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1399:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1400:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   return bitstatus;  
1401:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1209              		.loc 1 1401 0
 1210 0420 5DF8044B 		ldr	r4, [sp], #4
 1211 0424 7047     		bx	lr
 1212              		.cfi_endproc
 1213              	.LFE137:
 1215 0426 00BF     		.align	2
 1216              		.global	USART_ClearITPendingBit
 1217              		.thumb
 1218              		.thumb_func
 1220              	USART_ClearITPendingBit:
 1221              	.LFB138:
1402:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1403:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1404:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
1405:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1406:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1407:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
1408:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1409:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1410:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1411:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt. 
1412:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
1413:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
1414:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1415:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) pending bits are cleared by 
1416:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          software sequence: a read operation to USART_SR register 
1417:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
1418:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1419:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
1420:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1421:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TC pending bit can be also cleared by software sequence: a read 
1422:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
1423:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          operation to USART_DR register (USART_SendData()).
1424:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TXE pending bit is cleared only by a write to the USART_DR register 
1425:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1426:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *  
1427:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1428:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1429:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
1430:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1222              		.loc 1 1430 0
 1223              		.cfi_startproc
 1224              		@ args = 0, pretend = 0, frame = 0
 1225              		@ frame_needed = 0, uses_anonymous_args = 0
 1226              		@ link register save eliminated.
 1227              	.LVL143:
1431:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint16_t bitpos = 0x00, itmask = 0x00;
1432:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1433:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1434:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
1435:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1436:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1437:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1438:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1439:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1440:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1441:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1442:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 1228              		.loc 1 1442 0
 1229 0428 090A     		lsrs	r1, r1, #8
 1230              	.LVL144:
1443:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 1231              		.loc 1 1443 0
 1232 042a 0123     		movs	r3, #1
 1233 042c 8B40     		lsls	r3, r3, r1
 1234              	.LVL145:
1444:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~itmask;
 1235              		.loc 1 1444 0
 1236 042e DB43     		mvns	r3, r3
 1237              	.LVL146:
 1238 0430 9BB2     		uxth	r3, r3
 1239              	.LVL147:
 1240 0432 0380     		strh	r3, [r0]	@ movhi
 1241 0434 7047     		bx	lr
 1242              		.cfi_endproc
 1243              	.LFE138:
 1245              	.Letext0:
 1246              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q2\\arm-none-eabi\\include\\mach
 1247              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q2\\arm-none-eabi\\include\\stdi
 1248              		.file 4 "C:\\Users\\Filip\\Git\\STM32F4Discovery\\Eclipse\\StepDownConverter\\STM32F4xx\\Include/s
 1249              		.file 5 "C:\\Users\\Filip\\Git\\STM32F4Discovery\\Eclipse\\StepDownConverter\\STM32F4xx_StdPeriph_
 1250              		.file 6 "C:\\Users\\Filip\\Git\\STM32F4Discovery\\Eclipse\\StepDownConverter\\STM32F4xx_StdPeriph_
 1251              		.file 7 "C:\\Users\\Filip\\Git\\STM32F4Discovery\\Eclipse\\StepDownConverter\\CMSIS\\Include/core_
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f4xx_usart.c
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:18     .text:00000000 $t
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:23     .text:00000000 USART_DeInit
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:145    .text:000000a4 $d
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:154    .text:000000bc $t
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:159    .text:000000bc USART_Init
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:330    .text:00000180 $d
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:335    .text:00000188 $t
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:340    .text:00000188 USART_StructInit
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:372    .text:000001a0 USART_ClockInit
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:418    .text:000001c0 USART_ClockStructInit
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:444    .text:000001cc USART_Cmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:476    .text:000001e8 USART_SetPrescaler
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:503    .text:000001fc USART_OverSampling8Cmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:534    .text:00000218 USART_OneBitMethodCmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:566    .text:00000234 USART_SendData
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:587    .text:0000023c USART_ReceiveData
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:609    .text:00000244 USART_SetAddress
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:638    .text:0000025c USART_ReceiverWakeUpCmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:670    .text:00000278 USART_WakeUpConfig
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:699    .text:00000290 USART_LINBreakDetectLengthConfig
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:728    .text:000002a8 USART_LINCmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:760    .text:000002c4 USART_SendBreak
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:782    .text:000002d0 USART_HalfDuplexCmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:814    .text:000002ec USART_SetGuardTime
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:841    .text:00000300 USART_SmartCardCmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:873    .text:0000031c USART_SmartCardNACKCmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:905    .text:00000338 USART_IrDAConfig
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:934    .text:00000350 USART_IrDACmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:966    .text:0000036c USART_DMACmd
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:1001   .text:00000384 USART_ITConfig
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:1074   .text:000003c0 USART_GetFlagStatus
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:1105   .text:000003d0 USART_ClearFlag
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:1127   .text:000003d8 USART_GetITStatus
C:\Users\Filip\AppData\Local\Temp\ccmR4hvh.s:1220   .text:00000428 USART_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.1c01c98cf54d5aaab4df87c6bb476f00
                           .group:00000000 wm4.stm32f4xx.h.48.ab6cfc2433f704442c75c2d67f633280
                           .group:00000000 wm4.core_cm4.h.32.f824aba4d431a5bb4a51726bd5b62834
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.core_cmInstr.h.25.f50f886f2edf670cf199b35fd96f5c91
                           .group:00000000 wm4.core_cm4_simd.h.29.b4a3fdfb606cb3b26119424324d4b963
                           .group:00000000 wm4.core_cm4.h.153.5393ef7e6cebf34dd51ca528f9218ab3
                           .group:00000000 wm4.stm32f4xx.h.288.7f55b1a1f5e5bad6ffa2308f97f537d1
                           .group:00000000 wm4.stm32f4xx_conf.h.24.a762e2483b8e31b68046e44b31e1d406
                           .group:00000000 wm4.stm32f4xx_adc.h.102.2061aa73008746f3c2cc6ce8f635cad3
                           .group:00000000 wm4.stm32f4xx_can.h.25.87f18ca48b2692d39f76e87b1f07c953
                           .group:00000000 wm4.stm32f4xx_cryp.h.25.db1951c06ee684df97ea3a11aba6cb51
                           .group:00000000 wm4.stm32f4xx_dac.h.25.c43557a6416ea4dfa986c1209c2558d6
                           .group:00000000 wm4.stm32f4xx_dbgmcu.h.24.7aedfdcf091890b5cb96019bd29a2bfc
                           .group:00000000 wm4.stm32f4xx_dcmi.h.24.64883d9be802a535b1d7770d14da73e0
                           .group:00000000 wm4.stm32f4xx_dma.h.25.c1fa1d44ae0bc9c2b3a0d1d355d8c1e6
                           .group:00000000 wm4.stm32f4xx_exti.h.25.620998268d5d3d9042a8297fbe07d507
                           .group:00000000 wm4.stm32f4xx_flash.h.25.65d4f351b72ee41355279f70305f361a
                           .group:00000000 wm4.stm32f4xx_fsmc.h.25.b907ac7bd9bec46e02d06b137d53cfd8
                           .group:00000000 wm4.stm32f4xx_hash.h.25.633fb84f031cf2ab1bd834e536716dfa
                           .group:00000000 wm4.stm32f4xx_gpio.h.25.5bd1d790d742a307b55aea5fa8fcdae8
                           .group:00000000 wm4.stm32f4xx_i2c.h.25.8fcdb817a00a67d4624d79bab0d9275f
                           .group:00000000 wm4.stm32f4xx_iwdg.h.25.3013e8d2058415cb9d51af77f748a146
                           .group:00000000 wm4.stm32f4xx_pwr.h.25.41ffcb5dc896ed2d26edf4d9bbbfbe6f
                           .group:00000000 wm4.stm32f4xx_rcc.h.24.a10ec6e94989efb0f8f7f56448e9bb60
                           .group:00000000 wm4.stm32f4xx_rng.h.25.cdb5c5c07de6a48aedfde608da3f447e
                           .group:00000000 wm4.stm32f4xx_rtc.h.25.4809a79ad46ad97b4a01e735a96738eb
                           .group:00000000 wm4.stm32f4xx_sdio.h.25.406302aabae34eada94e5f2cde635a3e
                           .group:00000000 wm4.stm32f4xx_spi.h.25.980a9e96afe182c8b9cb91058a0693d6
                           .group:00000000 wm4.stm32f4xx_syscfg.h.25.9d5caab5677661b69e959531364e23d7
                           .group:00000000 wm4.stm32f4xx_tim.h.25.948f7fc943f34bd206e29758e77ee0a2
                           .group:00000000 wm4.stm32f4xx_wwdg.h.25.09d70b7849c6894ddf1e83c8e86b70e1
                           .group:00000000 wm4.misc.h.25.a0cb758c1f091b46f201b19cec9e63a1
                           .group:00000000 wm4.stm32f4xx.h.6972.f31ddedd83a17c461a3fab76f77123cb
                           .group:00000000 wm4.stm32f4xx_usart.h.104.14e758bb920cc835413a19eb02e177fb

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
